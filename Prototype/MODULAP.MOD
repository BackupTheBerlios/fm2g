IMPLEMENTATION MODULE ModulaP;

(* Parser generated by Coco/R - assuming ISO IO library will be available. *)

IMPORT ModulaS;



CONST 
  maxT = 65;
  minErrDist  =  2;  (* minimal distance (good tokens) between two errors *)
  setsize     = 16;  (* sets are stored in 16 bits *)

TYPE
  SymbolSet = ARRAY [0 .. maxT DIV setsize] OF BITSET;

VAR
  symSet:  ARRAY [0 ..   2] OF SymbolSet; (*symSet[0] = allSyncSyms*)
  errDist: CARDINAL;   (* number of symbols recognized since last error *)
  sym:     CARDINAL;   (* current input symbol *)

PROCEDURE SemError (errNo: INTEGER);
  BEGIN
    IF errDist >= minErrDist THEN
      ModulaS.Error(errNo, ModulaS.line, ModulaS.col, ModulaS.pos);
    END;
    errDist := 0;
  END SemError;

PROCEDURE SynError (errNo: INTEGER);
  BEGIN
    IF errDist >= minErrDist THEN
      ModulaS.Error(errNo, ModulaS.nextLine, ModulaS.nextCol, ModulaS.nextPos);
    END;
    errDist := 0;
  END SynError;

PROCEDURE Get;
  VAR
    s: ARRAY [0 .. 31] OF CHAR;
  BEGIN
    REPEAT
      ModulaS.Get(sym);
      IF sym <= maxT THEN
        INC(errDist);
      ELSE
        
      END;
    UNTIL sym <= maxT
  END Get;

PROCEDURE In (VAR s: SymbolSet; x: CARDINAL): BOOLEAN;
  BEGIN
    RETURN x MOD setsize IN s[x DIV setsize];
  END In;

PROCEDURE Expect (n: CARDINAL);
  BEGIN
    IF sym = n THEN Get ELSE SynError(n) END
  END Expect;

PROCEDURE ExpectWeak (n, follow: CARDINAL);
  BEGIN
    IF sym = n
      THEN Get
      ELSE SynError(n); WHILE ~ In(symSet[follow], sym) DO Get END
    END
  END ExpectWeak;

PROCEDURE WeakSeparator (n, syFol, repFol: CARDINAL): BOOLEAN;
  VAR
    s: SymbolSet;
    i: CARDINAL;
  BEGIN
    IF sym = n
      THEN Get; RETURN TRUE
      ELSIF In(symSet[repFol], sym) THEN RETURN FALSE
      ELSE
        i := 0;
        WHILE i <= maxT DIV setsize DO
          s[i] := symSet[0, i] + symSet[syFol, i] + symSet[repFol, i]; INC(i)
        END;
        SynError(n); WHILE ~ In(s, sym) DO Get END;
        RETURN In(symSet[syFol], sym)
    END
  END WeakSeparator;

PROCEDURE LexName (VAR Lex: ARRAY OF CHAR);
  BEGIN
    ModulaS.GetName(ModulaS.pos, ModulaS.len, Lex)
  END LexName;

PROCEDURE LexString (VAR Lex: ARRAY OF CHAR);
  BEGIN
    ModulaS.GetString(ModulaS.pos, ModulaS.len, Lex)
  END LexString;

PROCEDURE LookAheadName (VAR Lex: ARRAY OF CHAR);
  BEGIN
    ModulaS.GetName(ModulaS.nextPos, ModulaS.nextLen, Lex)
  END LookAheadName;

PROCEDURE LookAheadString (VAR Lex: ARRAY OF CHAR);
  BEGIN
    ModulaS.GetString(ModulaS.nextPos, ModulaS.nextLen, Lex)
  END LookAheadString;

PROCEDURE Successful (): BOOLEAN;
  BEGIN
    RETURN ModulaS.errors = 0
  END Successful;

(* ----- FORWARD not needed in multipass compilers

PROCEDURE Number; FORWARD;
PROCEDURE FactorOperator; FORWARD;
PROCEDURE Factor; FORWARD;
PROCEDURE TermOperator; FORWARD;
PROCEDURE Term; FORWARD;
PROCEDURE Relation; FORWARD;
PROCEDURE SimpleExpression; FORWARD;
PROCEDURE ConstExpression; FORWARD;
PROCEDURE CaseLabel; FORWARD;
PROCEDURE CaseLabelBlock; FORWARD;
PROCEDURE WithStatement; FORWARD;
PROCEDURE WhileStatement; FORWARD;
PROCEDURE RepeatStatement; FORWARD;
PROCEDURE LoopStatement; FORWARD;
PROCEDURE IfStatement; FORWARD;
PROCEDURE ForStatement; FORWARD;
PROCEDURE EmptyStatement; FORWARD;
PROCEDURE CaseStatement; FORWARD;
PROCEDURE ActualParameters; FORWARD;
PROCEDURE Element; FORWARD;
PROCEDURE SetMembers; FORWARD;
PROCEDURE SubRange; FORWARD;
PROCEDURE Enumeration; FORWARD;
PROCEDURE QualIdent; FORWARD;
PROCEDURE PointerType; FORWARD;
PROCEDURE SetType; FORWARD;
PROCEDURE RecordType; FORWARD;
PROCEDURE ArrayType; FORWARD;
PROCEDURE SimpleType; FORWARD;
PROCEDURE Expression; FORWARD;
PROCEDURE Type; FORWARD;
PROCEDURE ReturnType; FORWARD;
PROCEDURE ParameterList; FORWARD;
PROCEDURE ProcedureName; FORWARD;
PROCEDURE TypeDeclaration; FORWARD;
PROCEDURE ConstDeclaration; FORWARD;
PROCEDURE ImportList; FORWARD;
PROCEDURE Statements; FORWARD;
PROCEDURE Procedures; FORWARD;
PROCEDURE VARBlock; FORWARD;
PROCEDURE TYPEBlock; FORWARD;
PROCEDURE CONSTBlock; FORWARD;
PROCEDURE ImportBlock; FORWARD;
PROCEDURE ModuleName; FORWARD;
PROCEDURE Modula; FORWARD;

----- *)

PROCEDURE Number;
  BEGIN
    IF (sym = 2) THEN
      Get;
    ELSIF (sym = 3) THEN
      Get;
    ELSE SynError(66);
    END;
  END Number;

PROCEDURE FactorOperator;
  BEGIN
    IF (sym = 60) THEN
      Get;
    ELSIF (sym = 61) THEN
      Get;
    ELSIF (sym = 62) THEN
      Get;
    ELSIF (sym = 63) THEN
      Get;
    ELSIF (sym = 64) THEN
      Get;
    ELSE SynError(67);
    END;
  END FactorOperator;

PROCEDURE Factor;
  BEGIN
    IF (sym = 20) THEN
      Get;
      Expression;
      Expect(21);
    ELSIF (sym = 59) THEN
      Get;
      Factor;
    ELSIF (sym = 2) OR (sym = 3) THEN
      Number;
    ELSIF (sym = 4) THEN
      Get;
    ELSIF (sym = 1) THEN
      QualIdent;
      Expect(20);
      ActualParameters;
      Expect(21);
      Expect(12);
    ELSE SynError(68);
    END;
  END Factor;

PROCEDURE TermOperator;
  BEGIN
    IF (sym = 49) THEN
      Get;
    ELSIF (sym = 50) THEN
      Get;
    ELSIF (sym = 58) THEN
      Get;
    ELSE SynError(69);
    END;
  END TermOperator;

PROCEDURE Term;
  BEGIN
    Factor;
    WHILE (sym = 60) OR (sym = 61) OR (sym = 62) OR (sym = 63) OR (sym = 64) DO
      FactorOperator;
      Factor;
    END;
  END Term;

PROCEDURE Relation;
  BEGIN
    CASE sym OF
      15 :
        Get;
    | 51 :
        Get;
    | 52 :
        Get;
    | 53 :
        Get;
    | 54 :
        Get;
    | 55 :
        Get;
    | 56 :
        Get;
    | 57 :
        Get;
    ELSE SynError(70);
    END;
  END Relation;

PROCEDURE SimpleExpression;
  BEGIN
    IF (sym = 49) OR (sym = 50) THEN
      IF (sym = 49) THEN
        Get;
      ELSE
        Get;
      END;
    END;
    Term;
    WHILE (sym = 49) OR (sym = 50) OR (sym = 58) DO
      TermOperator;
      Term;
    END;
  END SimpleExpression;

PROCEDURE ConstExpression;
  BEGIN
    Expression;
  END ConstExpression;

PROCEDURE CaseLabel;
  BEGIN
    Expression;
    IF (sym = 31) THEN
      Get;
      Expression;
    END;
  END CaseLabel;

PROCEDURE CaseLabelBlock;
  BEGIN
    CaseLabel;
    Expect(17);
    Statements;
  END CaseLabelBlock;

PROCEDURE WithStatement;
  BEGIN
    Expect(48);
    QualIdent;
    Expect(40);
    Statements;
    Expect(9);
    Expect(12);
  END WithStatement;

PROCEDURE WhileStatement;
  BEGIN
    Expect(47);
    Expression;
    Expect(40);
    Statements;
    Expect(9);
    Expect(12);
  END WhileStatement;

PROCEDURE RepeatStatement;
  BEGIN
    Expect(45);
    Statements;
    Expect(46);
    Expression;
    Expect(9);
    Expect(12);
  END RepeatStatement;

PROCEDURE LoopStatement;
  BEGIN
    Expect(44);
    Statements;
    Expect(9);
    Expect(12);
  END LoopStatement;

PROCEDURE IfStatement;
  BEGIN
    Expect(41);
    Expression;
    Expect(42);
    Statements;
    WHILE (sym = 43) DO
      Get;
      Expression;
      Expect(42);
      Statements;
    END;
    IF (sym = 37) THEN
      Get;
      Statements;
    END;
    Expect(9);
    Expect(12);
  END IfStatement;

PROCEDURE ForStatement;
  BEGIN
    Expect(38);
    Expect(1);
    Expect(34);
    Expression;
    Expect(29);
    Expression;
    IF (sym = 39) THEN
      Get;
      ConstExpression;
    END;
    Expect(40);
    Statements;
    Expect(9);
    Expect(12);
  END ForStatement;

PROCEDURE EmptyStatement;
  BEGIN
    Expect(12);
  END EmptyStatement;

PROCEDURE CaseStatement;
  BEGIN
    Expect(35);
    Expression;
    Expect(23);
    CaseLabelBlock;
    WHILE (sym = 36) DO
      Get;
      CaseLabelBlock;
    END;
    IF (sym = 37) THEN
      Get;
      Statements;
    END;
    Expect(9);
    Expect(12);
  END CaseStatement;

PROCEDURE ActualParameters;
  BEGIN
    Expression;
    WHILE (sym = 13) DO
      Get;
      Expression;
    END;
  END ActualParameters;

PROCEDURE Element;
  BEGIN
    SimpleType;
  END Element;

PROCEDURE SetMembers;
  BEGIN
    Element;
    WHILE (sym = 13) DO
      Get;
      Element;
    END;
  END SetMembers;

PROCEDURE SubRange;
  BEGIN
    Expect(30);
    Expression;
    Expect(31);
    Expression;
    Expect(32);
  END SubRange;

PROCEDURE Enumeration;
  BEGIN
    Expect(20);
    Expect(1);
    WHILE (sym = 13) DO
      Get;
      Expect(1);
    END;
    Expect(21);
  END Enumeration;

PROCEDURE QualIdent;
  BEGIN
    Expect(1);
    WHILE (sym = 10) DO
      Get;
      Expect(1);
    END;
  END QualIdent;

PROCEDURE PointerType;
  BEGIN
    Expect(28);
    Expect(29);
    Type;
  END PointerType;

PROCEDURE SetType;
  BEGIN
    Expect(25);
    Expect(23);
    QualIdent;
    Expect(26);
    SetMembers;
    Expect(27);
  END SetType;

PROCEDURE RecordType;
  BEGIN
    Expect(24);
    WHILE (sym = 1) DO
      Get;
      Expect(17);
      Type;
      Expect(12);
    END;
    Expect(9);
    Expect(12);
  END RecordType;

PROCEDURE ArrayType;
  BEGIN
    Expect(22);
    SimpleType;
    WHILE (sym = 13) DO
      Get;
      SimpleType;
    END;
    Expect(23);
    Type;
  END ArrayType;

PROCEDURE SimpleType;
  BEGIN
    IF (sym = 1) THEN
      QualIdent;
    ELSIF (sym = 20) THEN
      Enumeration;
    ELSIF (sym = 30) THEN
      SubRange;
    ELSE SynError(71);
    END;
  END SimpleType;

PROCEDURE Expression;
  BEGIN
    SimpleExpression;
    WHILE In(symSet[1], sym) DO
      Relation;
      SimpleExpression;
    END;
  END Expression;

PROCEDURE Type;
  BEGIN
    CASE sym OF
      1, 20, 30 :
        SimpleType;
    | 22 :
        ArrayType;
    | 24 :
        RecordType;
    | 25 :
        SetType;
    | 28 :
        PointerType;
    | 19 :
        Procedures;
    ELSE SynError(72);
    END;
  END Type;

PROCEDURE ReturnType;
  BEGIN
    Expression;
  END ReturnType;

PROCEDURE ParameterList;
  BEGIN
    Expect(20);
    WHILE (sym = 1) OR (sym = 18) DO
      IF (sym = 18) THEN
        Get;
      END;
      Expect(1);
      Expect(17);
      Type;
    END;
    Expect(12);
    Expect(21);
  END ParameterList;

PROCEDURE ProcedureName;
  BEGIN
    Expect(1);
  END ProcedureName;

PROCEDURE TypeDeclaration;
  BEGIN
    Expect(1);
    Expect(15);
    Type;
  END TypeDeclaration;

PROCEDURE ConstDeclaration;
  BEGIN
    Expression;
  END ConstDeclaration;

PROCEDURE ImportList;
  BEGIN
    Expect(1);
    WHILE (sym = 13) DO
      Get;
      Expect(1);
    END;
  END ImportList;

PROCEDURE Statements;
  BEGIN
    CASE sym OF
      1 :
        QualIdent;
        IF (sym = 20) OR (sym = 33) OR (sym = 34) THEN
          IF (sym = 33) OR (sym = 34) THEN
            IF (sym = 33) THEN
              Get;
            END;
            Expect(34);
            Expression;
          ELSE
            Get;
            ActualParameters;
            Expect(21);
          END;
        END;
        Expect(12);
    | 35 :
        CaseStatement;
    | 12 :
        EmptyStatement;
    | 38 :
        ForStatement;
    | 41 :
        IfStatement;
    | 44 :
        LoopStatement;
    | 45 :
        RepeatStatement;
    | 47 :
        WhileStatement;
    | 48 :
        WithStatement;
    ELSE SynError(73);
    END;
  END Statements;

PROCEDURE Procedures;
  BEGIN
    Expect(19);
    ProcedureName;
    Expect(20);
    WHILE (sym = 20) DO
      ParameterList;
    END;
    Expect(21);
    IF (sym = 17) THEN
      Get;
      ReturnType;
    END;
    Expect(12);
    IF (sym = 14) THEN
      CONSTBlock;
    END;
    IF (sym = 16) THEN
      TYPEBlock;
    END;
    IF (sym = 18) THEN
      VARBlock;
    END;
    Expect(8);
    WHILE In(symSet[2], sym) DO
      Statements;
    END;
    Expect(9);
    ProcedureName;
    Expect(12);
  END Procedures;

PROCEDURE VARBlock;
  BEGIN
    Expect(18);
    WHILE (sym = 1) DO
      Get;
      Expect(17);
      TypeDeclaration;
      Expect(12);
    END;
  END VARBlock;

PROCEDURE TYPEBlock;
  BEGIN
    Expect(16);
    WHILE (sym = 1) DO
      Get;
      Expect(17);
      TypeDeclaration;
      Expect(12);
    END;
  END TYPEBlock;

PROCEDURE CONSTBlock;
  BEGIN
    Expect(14);
    WHILE (sym = 1) DO
      Get;
      Expect(15);
      ConstDeclaration;
      Expect(12);
    END;
  END CONSTBlock;

PROCEDURE ImportBlock;
  BEGIN
    Expect(11);
    Expect(1);
    ImportList;
    Expect(12);
  END ImportBlock;

PROCEDURE ModuleName;
  BEGIN
    Expect(1);
  END ModuleName;

PROCEDURE Modula;
  BEGIN
    IF (sym = 5) OR (sym = 6) OR (sym = 7) THEN
      IF (sym = 5) THEN
        Get;
        Expect(6);
      ELSIF (sym = 7) THEN
        Get;
        Expect(6);
      ELSE
        Get;
      END;
    END;
    ModuleName;
    IF (sym = 11) THEN
      ImportBlock;
    END;
    IF (sym = 14) THEN
      CONSTBlock;
    END;
    IF (sym = 16) THEN
      TYPEBlock;
    END;
    IF (sym = 18) THEN
      VARBlock;
    END;
    WHILE (sym = 19) DO
      Procedures;
    END;
    Expect(8);
    WHILE In(symSet[2], sym) DO
      Statements;
    END;
    Expect(9);
    ModuleName;
    Expect(10);
  END Modula;



PROCEDURE Parse;
  BEGIN
    ModulaS.Reset; Get;
    Modula;

  END Parse;

BEGIN
  errDist := minErrDist;
  symSet[ 0, 0] := BITSET{0};
  symSet[ 0, 1] := BITSET{};
  symSet[ 0, 2] := BITSET{};
  symSet[ 0, 3] := BITSET{};
  symSet[ 0, 4] := BITSET{};
  symSet[ 1, 0] := BITSET{15};
  symSet[ 1, 1] := BITSET{};
  symSet[ 1, 2] := BITSET{};
  symSet[ 1, 3] := BITSET{3, 4, 5, 6, 7, 8, 9};
  symSet[ 1, 4] := BITSET{};
  symSet[ 2, 0] := BITSET{1, 12};
  symSet[ 2, 1] := BITSET{};
  symSet[ 2, 2] := BITSET{3, 6, 9, 12, 13, 15};
  symSet[ 2, 3] := BITSET{0};
  symSet[ 2, 4] := BITSET{};
END ModulaP.

