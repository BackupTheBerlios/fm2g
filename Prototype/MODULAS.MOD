IMPLEMENTATION MODULE ModulaS;

(* Scanner generated by Coco/R - assuming ISO IO library will be available. *)

IMPORT Storage, IOChan;

CONST
  noSYMB  = 65; (*error token code*)
  (* not only for errors but also for not finished states of scanner analysis *)
  eof     = 32C (* MS-DOS Keyboard eof char *);
  EOF     = 0C;
  EOL     = 15C;
  CR      = 15C;
  LF      = 12C;
  Long0   = 0;
  Long1   = 1;
  BlkSize = 16384;
TYPE
  BufBlock   = ARRAY [0 .. BlkSize-1] OF CHAR;
  Buffer     = ARRAY [0 .. 31] OF POINTER TO BufBlock;
  StartTable = ARRAY [0 .. 255] OF INTEGER;
  GetCH      = PROCEDURE (INT32): CHAR;
VAR
  lastCh,
  ch:        CHAR;       (*current input character*)
  curLine:   INTEGER;    (*current input line (may be higher than line)*)
  lineStart: INT32;      (*start position of current line*)
  apx:       INT32;      (*length of appendix (CONTEXT phrase)*)
  oldEols:   INTEGER;    (*number of EOLs in a comment*)
  bp, bp0:   INT32;      (*current position in buf
                           (bp0: position of current token)*)
  inputLen:  INT32;      (*source file size*)
  buf:       Buffer;     (*source buffer for low-level access*)
  start:     StartTable; (*start state for every character*)
  CurrentCh: GetCH;

PROCEDURE ORDL (n: INT32): CARDINAL;
 BEGIN
   RETURN VAL(CARDINAL, n)
 END ORDL;

PROCEDURE Err (nr, line, col: INTEGER; pos: INT32);
  BEGIN
    INC(errors)
  END Err;

PROCEDURE NextCh;
(* Return global variable ch *)
  BEGIN
    lastCh := ch; INC(bp); ch := CurrentCh(bp);
    IF (ch = EOL) OR (ch = LF) AND (lastCh # EOL) THEN
      INC(curLine); lineStart := bp
    END
  END NextCh;

PROCEDURE Comment (): BOOLEAN;
  VAR
    level, startLine: INTEGER;
    oldLineStart: INT32;
  BEGIN
    level := 1; startLine := curLine; oldLineStart := lineStart;
    IF (ch = "(") THEN
      NextCh;
      IF (ch = "*") THEN
        NextCh;
        LOOP
          IF (ch = "*") THEN
            NextCh;
            IF (ch = ")") THEN
              DEC(level); NextCh;
              IF level = 0 THEN RETURN TRUE END
            END;
          ELSIF (ch = "(") THEN
            NextCh;
            IF (ch = "*") THEN INC(level); NextCh END;
          ELSIF ch = EOF THEN RETURN FALSE
          ELSE NextCh END;
        END; (* LOOP *)
      ELSE
        IF (ch = CR) OR (ch = LF) THEN
          DEC(curLine); lineStart := oldLineStart
        END;
        DEC(bp); ch := lastCh;
      END;
    END;
    RETURN FALSE;
  END Comment;

PROCEDURE Get (VAR sym: CARDINAL);
  VAR
    state: CARDINAL;

  PROCEDURE Equal (s: ARRAY OF CHAR): BOOLEAN;
    VAR
      i: CARDINAL;
      q: INT32;
    BEGIN
      IF nextLen # LENGTH(s) THEN RETURN FALSE END;
      i := 1; q := bp0; INC(q);
      WHILE i < nextLen DO
        IF CurrentCh(q) # s[i] THEN RETURN FALSE END;
        INC(i); INC(q)
      END;
      RETURN TRUE
    END Equal;

  PROCEDURE CheckLiteral;
    BEGIN
      CASE CurrentCh(bp0) OF
        "A": IF Equal("AND") THEN sym := 64; 
             ELSIF Equal("ARRAY") THEN sym := 22; 
             END
      | "B": IF Equal("BEGIN") THEN sym := 8; 
             ELSIF Equal("BY") THEN sym := 39; 
             END
      | "C": IF Equal("CASE") THEN sym := 35; 
             ELSIF Equal("CONST") THEN sym := 14; 
             END
      | "D": IF Equal("DEFINITION") THEN sym := 5; 
             ELSIF Equal("DIV") THEN sym := 62; 
             ELSIF Equal("DO") THEN sym := 40; 
             END
      | "E": IF Equal("ELSE") THEN sym := 37; 
             ELSIF Equal("ELSIF") THEN sym := 43; 
             ELSIF Equal("END") THEN sym := 9; 
             END
      | "F": IF Equal("FOR") THEN sym := 38; 
             ELSIF Equal("FROM") THEN sym := 11; 
             END
      | "I": IF Equal("IF") THEN sym := 41; 
             ELSIF Equal("IMPLEMENTATION") THEN sym := 7; 
             ELSIF Equal("IN") THEN sym := 57; 
             END
      | "L": IF Equal("LOOP") THEN sym := 44; 
             END
      | "M": IF Equal("MOD") THEN sym := 63; 
             ELSIF Equal("MODULE") THEN sym := 6; 
             END
      | "N": IF Equal("NOT") THEN sym := 59; 
             END
      | "O": IF Equal("OF") THEN sym := 23; 
             ELSIF Equal("OR") THEN sym := 58; 
             END
      | "P": IF Equal("POINTER") THEN sym := 28; 
             ELSIF Equal("PROCEDURE") THEN sym := 19; 
             END
      | "R": IF Equal("RECORD") THEN sym := 24; 
             ELSIF Equal("REPEAT") THEN sym := 45; 
             END
      | "S": IF Equal("SET") THEN sym := 25; 
             END
      | "T": IF Equal("THEN") THEN sym := 42; 
             ELSIF Equal("TO") THEN sym := 29; 
             ELSIF Equal("TYPE") THEN sym := 16; 
             END
      | "U": IF Equal("UNTIL") THEN sym := 46; 
             END
      | "V": IF Equal("VAR") THEN sym := 18; 
             END
      | "W": IF Equal("WHILE") THEN sym := 47; 
             ELSIF Equal("WITH") THEN sym := 48; 
             END
      ELSE
      END
    END CheckLiteral;

  BEGIN (*Get*)
    WHILE (ch = ' ') OR
          ((ch >= CHR(9)) & (ch <= CHR(13))) DO NextCh END;
    IF ((ch = "(")) & Comment() THEN Get(sym); RETURN END;
    pos := nextPos;   nextPos := bp;
    col := nextCol;   nextCol := VAL(INTEGER, bp - lineStart);
    line := nextLine; nextLine := curLine;
    len := nextLen;   nextLen := 0;
    apx := 0; state := start[ORD(ch)]; bp0 := bp;
    LOOP
      NextCh; INC(nextLen);
      CASE state OF
         1: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "Z") OR
               (ch >= "a") & (ch <= "z")) THEN 
            ELSE sym := 1; CheckLiteral; RETURN
            END;
      |  2: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "F")) THEN 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := noSYMB; RETURN
            END;
      |  3: bp := bp - apx - Long1; DEC(nextLen, ORDL(apx)); NextCh; sym := 2; RETURN
      |  4: sym := 2; RETURN
      |  5: IF ((ch >= "0") & (ch <= "9")) THEN 
            ELSIF (ch = "E") THEN state := 6; 
            ELSE sym := 3; RETURN
            END;
      |  6: IF ((ch >= "0") & (ch <= "9")) THEN state := 8; 
            ELSIF ((ch = "+") OR
                  (ch = "-")) THEN state := 7; 
            ELSE sym := noSYMB; RETURN
            END;
      |  7: IF ((ch >= "0") & (ch <= "9")) THEN state := 8; 
            ELSE sym := noSYMB; RETURN
            END;
      |  8: IF ((ch >= "0") & (ch <= "9")) THEN 
            ELSE sym := 3; RETURN
            END;
      |  9: IF ((ch <= CHR(12)) OR
               (ch >= CHR(14)) & (ch <= "&") OR
               (ch >= "(")) THEN 
            ELSIF (ch = "'") THEN state := 11; 
            ELSE sym := noSYMB; RETURN
            END;
      | 10: IF ((ch <= CHR(12)) OR
               (ch >= CHR(14)) & (ch <= "!") OR
               (ch >= "#")) THEN 
            ELSIF (ch = '"') THEN state := 11; 
            ELSE sym := noSYMB; RETURN
            END;
      | 11: sym := 4; RETURN
      | 12: IF ((ch >= "0") & (ch <= "9")) THEN 
            ELSIF ((ch >= "A") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = ".") THEN state := 14; INC(apx) 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := 2; RETURN
            END;
      | 13: IF ((ch >= "8") & (ch <= "9")) THEN state := 12; 
            ELSIF ((ch >= "0") & (ch <= "7")) THEN 
            ELSIF ((ch = "A") OR
                  (ch >= "D") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = ".") THEN state := 14; INC(apx) 
            ELSIF (ch = "B") THEN state := 15; 
            ELSIF (ch = "C") THEN state := 16; 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := 2; RETURN
            END;
      | 14: IF ((ch >= "0") & (ch <= "9")) THEN state := 5; apx := Long0 
            ELSIF (ch = ".") THEN state := 3; INC(apx) 
            ELSIF (ch = "E") THEN state := 6; apx := Long0 
            ELSE sym := 3; RETURN
            END;
      | 15: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := 2; RETURN
            END;
      | 16: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := 2; RETURN
            END;
      | 17: IF (ch = ".") THEN state := 27; 
            ELSE sym := 10; RETURN
            END;
      | 18: sym := 12; RETURN
      | 19: sym := 13; RETURN
      | 20: sym := 15; RETURN
      | 21: IF (ch = "=") THEN state := 30; 
            ELSE sym := 17; RETURN
            END;
      | 22: sym := 20; RETURN
      | 23: sym := 21; RETURN
      | 24: sym := 26; RETURN
      | 25: sym := 27; RETURN
      | 26: sym := 30; RETURN
      | 27: sym := 31; RETURN
      | 28: sym := 32; RETURN
      | 29: sym := 33; RETURN
      | 30: sym := 34; RETURN
      | 31: sym := 36; RETURN
      | 32: sym := 49; RETURN
      | 33: sym := 50; RETURN
      | 34: sym := 51; RETURN
      | 35: IF (ch = "=") THEN state := 36; 
            ELSIF (ch = ">") THEN state := 37; 
            ELSE sym := 52; RETURN
            END;
      | 36: sym := 53; RETURN
      | 37: sym := 54; RETURN
      | 38: IF (ch = "=") THEN state := 39; 
            ELSE sym := 55; RETURN
            END;
      | 39: sym := 56; RETURN
      | 40: sym := 60; RETURN
      | 41: sym := 61; RETURN
      | 42: sym := 0; ch := 0C; DEC(bp); RETURN
      ELSE sym := noSYMB; RETURN (*NextCh already done*)
      END
    END
  END Get;

PROCEDURE GetString (pos: INT32; len: CARDINAL; VAR s: ARRAY OF CHAR);
  VAR
    i: CARDINAL;
    p: INT32;
  BEGIN
    IF len > HIGH(s) THEN len := HIGH(s) END;
    p := pos; i := 0;
    WHILE i < len DO
      s[i] := CharAt(p); INC(i); INC(p)
    END;
    s[len] := 0C;
  END GetString;

PROCEDURE GetName (pos: INT32; len: CARDINAL; VAR s: ARRAY OF CHAR);
  VAR
    i: CARDINAL;
    p: INT32;
  BEGIN
    IF len > HIGH(s) THEN len := HIGH(s) END;
    p := pos; i := 0;
    WHILE i < len DO
      s[i] := CurrentCh(p); INC(i); INC(p)
    END;
    s[len] := 0C;
  END GetName;

PROCEDURE CharAt (pos: INT32): CHAR;
  VAR
    ch: CHAR;
  BEGIN
    IF pos >= inputLen THEN RETURN EOF END;
    ch := buf[ORD(pos DIV BlkSize)]^[ORD(pos MOD BlkSize)];
    IF ch # eof THEN RETURN ch ELSE RETURN EOF END
  END CharAt;

PROCEDURE CapChAt (pos: INT32): CHAR;
  VAR
    ch: CHAR;
  BEGIN
    IF pos >= inputLen THEN RETURN EOF END;
    ch := CAP(buf[ORD(pos DIV BlkSize)]^[ORD(pos MOD BlkSize)]);
    IF ch # eof THEN RETURN ch ELSE RETURN EOF END
  END CapChAt;

PROCEDURE Reset;
  VAR
    i, read: CARDINAL;
  BEGIN (*assert: src has been opened*)
    i := 0; inputLen := 0;
    REPEAT
      Storage.ALLOCATE(buf[i], BlkSize);
      IOChan.RawRead(src, buf[i], BlkSize, read);
      INC(i); INC(inputLen, VAL(INT32, read))
    UNTIL read # BlkSize;
    buf[i-1]^[read] := EOF;
    curLine := 1; lineStart := -2; bp := -1;
    oldEols := 0; apx := 0; errors := 0;
    NextCh;
  END Reset;

BEGIN
  CurrentCh := CharAt;
  start[  0] := 42; start[  1] := 43; start[  2] := 43; start[  3] := 43; 
  start[  4] := 43; start[  5] := 43; start[  6] := 43; start[  7] := 43; 
  start[  8] := 43; start[  9] := 43; start[ 10] := 43; start[ 11] := 43; 
  start[ 12] := 43; start[ 13] := 43; start[ 14] := 43; start[ 15] := 43; 
  start[ 16] := 43; start[ 17] := 43; start[ 18] := 43; start[ 19] := 43; 
  start[ 20] := 43; start[ 21] := 43; start[ 22] := 43; start[ 23] := 43; 
  start[ 24] := 43; start[ 25] := 43; start[ 26] := 43; start[ 27] := 43; 
  start[ 28] := 43; start[ 29] := 43; start[ 30] := 43; start[ 31] := 43; 
  start[ 32] := 43; start[ 33] := 43; start[ 34] := 10; start[ 35] := 34; 
  start[ 36] := 43; start[ 37] := 43; start[ 38] := 43; start[ 39] :=  9; 
  start[ 40] := 22; start[ 41] := 23; start[ 42] := 40; start[ 43] := 32; 
  start[ 44] := 19; start[ 45] := 33; start[ 46] := 17; start[ 47] := 41; 
  start[ 48] := 13; start[ 49] := 13; start[ 50] := 13; start[ 51] := 13; 
  start[ 52] := 13; start[ 53] := 13; start[ 54] := 13; start[ 55] := 13; 
  start[ 56] := 12; start[ 57] := 12; start[ 58] := 21; start[ 59] := 18; 
  start[ 60] := 35; start[ 61] := 20; start[ 62] := 38; start[ 63] := 43; 
  start[ 64] := 43; start[ 65] :=  1; start[ 66] :=  1; start[ 67] :=  1; 
  start[ 68] :=  1; start[ 69] :=  1; start[ 70] :=  1; start[ 71] :=  1; 
  start[ 72] :=  1; start[ 73] :=  1; start[ 74] :=  1; start[ 75] :=  1; 
  start[ 76] :=  1; start[ 77] :=  1; start[ 78] :=  1; start[ 79] :=  1; 
  start[ 80] :=  1; start[ 81] :=  1; start[ 82] :=  1; start[ 83] :=  1; 
  start[ 84] :=  1; start[ 85] :=  1; start[ 86] :=  1; start[ 87] :=  1; 
  start[ 88] :=  1; start[ 89] :=  1; start[ 90] :=  1; start[ 91] := 26; 
  start[ 92] := 43; start[ 93] := 28; start[ 94] := 29; start[ 95] := 43; 
  start[ 96] := 43; start[ 97] :=  1; start[ 98] :=  1; start[ 99] :=  1; 
  start[100] :=  1; start[101] :=  1; start[102] :=  1; start[103] :=  1; 
  start[104] :=  1; start[105] :=  1; start[106] :=  1; start[107] :=  1; 
  start[108] :=  1; start[109] :=  1; start[110] :=  1; start[111] :=  1; 
  start[112] :=  1; start[113] :=  1; start[114] :=  1; start[115] :=  1; 
  start[116] :=  1; start[117] :=  1; start[118] :=  1; start[119] :=  1; 
  start[120] :=  1; start[121] :=  1; start[122] :=  1; start[123] := 24; 
  start[124] := 31; start[125] := 25; start[126] := 43; start[127] := 43; 
  start[128] := 43; start[129] := 43; start[130] := 43; start[131] := 43; 
  start[132] := 43; start[133] := 43; start[134] := 43; start[135] := 43; 
  start[136] := 43; start[137] := 43; start[138] := 43; start[139] := 43; 
  start[140] := 43; start[141] := 43; start[142] := 43; start[143] := 43; 
  start[144] := 43; start[145] := 43; start[146] := 43; start[147] := 43; 
  start[148] := 43; start[149] := 43; start[150] := 43; start[151] := 43; 
  start[152] := 43; start[153] := 43; start[154] := 43; start[155] := 43; 
  start[156] := 43; start[157] := 43; start[158] := 43; start[159] := 43; 
  start[160] := 43; start[161] := 43; start[162] := 43; start[163] := 43; 
  start[164] := 43; start[165] := 43; start[166] := 43; start[167] := 43; 
  start[168] := 43; start[169] := 43; start[170] := 43; start[171] := 43; 
  start[172] := 43; start[173] := 43; start[174] := 43; start[175] := 43; 
  start[176] := 43; start[177] := 43; start[178] := 43; start[179] := 43; 
  start[180] := 43; start[181] := 43; start[182] := 43; start[183] := 43; 
  start[184] := 43; start[185] := 43; start[186] := 43; start[187] := 43; 
  start[188] := 43; start[189] := 43; start[190] := 43; start[191] := 43; 
  start[192] := 43; start[193] := 43; start[194] := 43; start[195] := 43; 
  start[196] := 43; start[197] := 43; start[198] := 43; start[199] := 43; 
  start[200] := 43; start[201] := 43; start[202] := 43; start[203] := 43; 
  start[204] := 43; start[205] := 43; start[206] := 43; start[207] := 43; 
  start[208] := 43; start[209] := 43; start[210] := 43; start[211] := 43; 
  start[212] := 43; start[213] := 43; start[214] := 43; start[215] := 43; 
  start[216] := 43; start[217] := 43; start[218] := 43; start[219] := 43; 
  start[220] := 43; start[221] := 43; start[222] := 43; start[223] := 43; 
  start[224] := 43; start[225] := 43; start[226] := 43; start[227] := 43; 
  start[228] := 43; start[229] := 43; start[230] := 43; start[231] := 43; 
  start[232] := 43; start[233] := 43; start[234] := 43; start[235] := 43; 
  start[236] := 43; start[237] := 43; start[238] := 43; start[239] := 43; 
  start[240] := 43; start[241] := 43; start[242] := 43; start[243] := 43; 
  start[244] := 43; start[245] := 43; start[246] := 43; start[247] := 43; 
  start[248] := 43; start[249] := 43; start[250] := 43; start[251] := 43; 
  start[252] := 43; start[253] := 43; start[254] := 43; start[255] := 43; 
  Error := Err; lastCh := EOF;
END ModulaS.
